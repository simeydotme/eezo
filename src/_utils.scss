
// Removes the unit (e.g. px, em, rem) from a value, returning the number only.
// @param {Number} $num - Number to strip unit from.
// @returns {Number} - The same number, sans unit.
// - borrowed from Zurb Foundation 6.
@function strip( $num ) {

    @return $num / ($num * 0 + 1);

}



// Returns a rem value based on %/px input
// @param {Number} $convert - input value of %/px.
// @returns {Number} - Input converted to rem unit.
// - inspired by Zurb Foundation 6.
@function rems( $convert ) {

    $unit: unit( $convert );
    $value: strip( $convert );
    $base: $rem;
    
    // error handling for non-px / non-% / non-rem values.
    @if ( $unit != "%" ) and ( $unit != "px" ) and ( $unit != "rem" ) {

        @warn $convert + " was passed to rems(), which may be incorrect.";
        @return $convert;

    }

    // if the font sizes are %, then multiply them by 16px
    // this is because 100% font size = 16px in most all browsers
    @if $unit == "%" {
        $value: strip( ( $convert / 100% ) * 16px );
    }
    
    // convert $base to px
    @if unit( $base ) == "%" {
        $base: ( $base / 100% ) * 16px;
    }

    // calculate rem if units for $unit is not rem
    @if $unit != "rem" {
        $value: $value / strip( $base ) * 1rem;
    }

    // convert 0rem into 0
    @if $value == 0rem {
        $value: 0;
    }

    @return $value;

}



// Converts a unitless, pixel, or rem value to em, for use in breakpoints.
// @param {Number} $convert - Number with a %/px/rem unit
// @returns {Number} - Input converted to ems
// - borrowed from Zurb Foundation 6.
@function ems( $convert ) {    

    $unit: unit( $convert );

    @if $unit == "rem" or $unit == "px" {
    
        // the value is converted to ems
        @return strip( rems( $convert ) ) * 1em;
    
    }

    @else if $unit == "em" or unitless( $convert ) {
        
        // convert from em / unitless
        @return strip( $convert ) * 1em;

    }

    @else {

        // if the value wasnt converted then return original
        @return $convert;

    }

}



// Generates a media query string matching the input value.
// @param {Keyword|Number} $val [mb] - Breakpoint name, or px, rem, or em value to process.
// @returns {String} - <edia query string for use with @breakpoint mixin.
// - borrowed from Zurb Foundation 6
@function breakpoint( $val: mb ) {

    // Size or keyword
    $bp: nth( $val, 1 );

    // Value for max-width media queries
    $bp-max: 0;

    // Direction of media query (up, down, or only)
    $dir: if( length( $val ) > 1, nth( $val, 2 ), up );

    // Eventual output
    $str: "";

    // Is it a named media query?
    $named: false;

    // Orientation media queries have a unique syntax
    @if $bp == "landscape" or $bp == "portrait" {
        @return "(orientation: #{$bp})";
    }

    @else if $bp == "retina" or $bp == "hdpi" {
        @return "(-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi)";
    }

    // Try to pull a named breakpoint out of the $breakpoints map
    @if type-of( $bp ) == "string" {
        @if map-has-key($breakpoints, $bp) {
            @if $dir == "only" or $dir == "down" {

                $next-bp: map-next($breakpoints, $bp);

                @if $next-bp == null {
                    $bp-max: null;
                    @warn "breakpoint(): the media query '#{$val}' cannot be used because '#{$bp}' is the largest breakpoint.";
                }

                @else {
                    $bp-max: $next-bp;
                }

            }

            $bp: map-get($breakpoints, $bp);
            $named: true;

        }
        
        @else {
            @warn "Couldn't find '#{$bp}' in $breakpoints list";
            $bp: 0;
        }
    }

    // Convert any pixel, rem, or unitless value to em
    $bp: ems( $bp );
    @if $bp-max {
        $bp-max: ems( $bp-max ) - (1/16);
    }

    // Skip media query creation if the input is "0 up"
    @if $bp > 0em or $dir == "only" or $dir == "down" {
        // `only` ranges use the format `(min-width: n) and (max-width: n)`
        @if $dir == "only" {

            @if $named == true {

                $str: $str + "(min-width: #{$bp})";

                @if $bp-max != null {
                    $str: $str + " and (max-width: #{$bp-max})";
                }

            }

            @else {

                @warn "Only named media queries can have an `only` range.";

            }

        }

        // `down` ranges use the format `(max-width: n)`
        @else if $dir == "down" {

            $max: 0;

            // For named breakpoints, subtract the breakpoint value by one "pixel", or 1/16em.
            @if $named {
                $max: $bp-max;
            }

            @else {
                $max: $bp;
            }

            // Skip media query creation if input value is exactly "0 down" but don't "small down"
            @if $named or $bp > 0em {
                $str: $str + "(max-width: #{$max})";
            }

        }

        // `up` ranges use the format `(min-width: n)`
        @else if $bp > 0em {
          $str: $str + "(min-width: #{$bp})";
        }
    }

    @return $str;

}



// Find the next key in a map.
// @param {Map} $map - Map to traverse.
// @param {Mixed} $key - Key to use as a starting point.
// @returns {Mixed} The value for the key after `$key`, if `$key` was found. If `$key` was not found, or `$key` was the last value in the map, returns `null`.
// - borrowed from Zurb Foundation 6

@function map-next( $map, $key ) {

    // Store the values of the map as a list, so we can access them with nth
    $values: map-values( $map );

    // Ghetto for loop
    $i: 1;
    $found: false;
    @each $val in map-keys( $map ) {

        @if $found == false {

            @if ( $key == $val ) {
                $found: true;
            }

            $i: $i + 1;

        }

    }

    // If the key doesn't exist, or it's the last key in the map, return null
    @if $i > length( $map ) {
        @return null;
    }

    // Otherwise, return the value
    @else {
        @return nth( $values, $i );
    }

}