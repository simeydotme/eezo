
extends ./layout/columns

block title
    | docs | media queries








append content



    +main-title( "Media Queries" )

    +intro-text
        :marked
            Having a **composable css class system** would not
            be very useful if it only applied to a single breakpoint.

    :marked
        A lot of layout and **design needs to shift** according to the
        size of the **user's screen**, and so we are able to
        prefix the css classes with `tb-*` and `dt-*` by default
        to allow a [mobile-first](http://zellwk.com/blog/how-to-write-mobile-first-css/)
        approach to design.

        **Not all components** of Eezo **have media-specific class
        prefixes**. This is because some of the css properties are
        considered to be _screen-size-agnostic_; you shouldn't need to
        change the `cursor` style, or `font-weight` across screen sizes.
        *With that being said, it may be possible in future to decide
        the breakpoints for each component.*




    +sub-title( "Default Breakpoints" )

    :marked
        The **default breakpoints** are defined in a way **which I find**
        is how most non-developers think about responsive design; in
        the "_mobile, tablet, desktop_" mind-set.

        I am **not saying this is correct**, but due to the popularity of
        certain devices, and the general way css frameworks are built,
        this information has been spread _for better or worse_.

        _But the beauty is that these defaults are configurable, and
        overridable!!_


    +sub-title( "Values" )

    :marked
        Here's a look at the default values for the `$breakpoints` map.
        This map is used throughout the components to define the `min-width`
        breakpoints.

    :prismjs( language = "scss" )
        // the breakpoints defined, and their
        // corresponding min-width values.
        $breakpoints: (
            mb: 0,
            tb: 768px,
            dt: 1024px,
            hg: 1200px,
        ) !default;

    :marked
        This means that anything with the `mb` prefix will be
        applied universally. But anything with
        - `tb` prefix, applies to `768px` and up
        - `dt` prefix, applies to `1024px` and up
        - `hg` prefix, applies to `1200px` and up

        Although, technically no components use `hg`, that
        breakpoint, by default, is just there for custom
        css.

    :prismjs( language = "scss" )
        // the default breakpoints list
        $default-bps: ("mb", "tb", "dt") !default;

    :marked
        The list shown above is a set of references to the `$breakpoints` map.

        The way this works is that in each component which supports media query
        prefixes, we will loop through this list, and attempt to pluck each
        media query definition from the `$breakpoints` map.

        The components **will not create a prefix for the first item**
        in this list, so the class for `font-size: 1rem` **will not be**:

    :prismjs( language = "css" )
        .mb-f0 { font-size: 1rem; }
        .tb-f0 { font-size: 1rem; }
        .dt-f0 { font-size: 1rem; }

    :marked
        but **will, in fact, be**:

    :prismjs( language = "css" )
        .f0 { font-size: 1rem; }
        .tb-f0 { font-size: 1rem; }
        .dt-f0 { font-size: 1rem; }

    +sub-title( "Customising" )

    :marked
        Eezo does not presume to say what breakpoints you should use
        in your application, that's your choice and so it's
        pretty easy to customise them by defining your own
        `$breakpoints` map and `$default-bps` list;

    +small-title( "General Breakpoints" )

    :marked
        There's a global default for breakpoints, which when
        modified will apply to all components and update their
        prefixes accordingly.

    :prismjs( language = "scss" )
        // let's change the breakpoints
        // to something similar to bootstrap;

        $breakpoints: (

            xs: 0,
            sm: 768px,
            md: 992px,
            lg: 1200px

        );

        // and define the list to reference
        // all these breakpoints;

        $default-bps: ( "xs", "sm", "md", "lg" );

    :marked
        With the code block above placed in to your `.scss` file
        (as described in the [customising Eezo section](xxcxx)) an
        example output of code for the `display` component would be:

    :prismjs( language = "css" )
        /* an example of the code now generated by
            the customised breakpoints */

            .disp-n  { display: none; }
            .disp-i  { display: inline; }
            .disp-b  { display: block; }
            /* ... */

        @media screen and ( min-width: 48em ) {
            .sm-disp-n  { display: none; }
            .sm-disp-i  { display: inline; }
            .sm-disp-b  { display: block; }
            /* ... */
        }

        @media screen and ( min-width: 62em ) {
            .md-disp-n  { display: none; }
            .md-disp-i  { display: inline; }
            .md-disp-b  { display: block; }
            /* ... */
        }

        @media screen and ( min-width: 75em ) {
            .lg-disp-n  { display: none; }
            .lg-disp-i  { display: inline; }
            .lg-disp-b  { display: block; }
            /* ... */
        }

    :marked
        As you can see, the generation of this code is
        automatic, and required little effort from the
        developer.

    +small-title( "Targetted Breakpoints" )

    :marked
        Aside from the global breakpoints, it's also
        possible to define breakpoints for each component
        individually. This is useful if you think that
        one component will need more/less breakpoints
        than the rest of the application.

    :prismjs( language = "scss" )
        // we will make floats only apply
        // to the small and large breakpoints we
        // defined above in $breakpoints.
        $float-bps: ( "xs", "lg" );

    :marked
        This would then generate the `float` component with
        less breakpoint-specific prefixes than the rest
        of the application.

    :prismjs( language = "css" )
        /* an example of the code now generated by
            the customised float breakpoints */

        .float-l { float: left; }
        .float-r { float: right; }
        .float-n { float: none; }

        @media screen and ( min-width: 75em ) {
            .float-l { float: left; }
            .float-r { float: right; }
            .float-n { float: none; }
        }

    +sub-title( "Best Practises" )

    :marked
        _Refer to the [Tips & Tricks section]() for a more
        general overview of best practises._

        These breakpoints apply to a large number of
        components with a lot of css. Although Eezo is designed
        to [take advantage of GZIP](http://www.infinitepartitions.com/art001.html)
        by having a lot of repetitive code; it is not ideal
        to be supplying a large number of breakpoints
        for a few reasons;

        1. **User Experience** - You do not want a large amount of
        css repeated unnecessarily, it will bloat your css
        file and increase download times.
        2. **Developer Usability** - Trying to remember a large
        amount of breakpoints to use will be troublesome.

    +small-title( "Only Neccessary Breakpoints" )

    :marked
        Try to **keep your defined breakpoints to a minimum**.
        If you find a reason to have more breakpoints,
        consider [modifying the `$*-bps` variable](#targetted-breakpoints) for **specific
        components** rather than applying them globally.

    +small-title( "Augment with BEM" )

    :marked
        Eezo is a composable class framework designed to create
        a **reusable system** across your application. But that **doesn't
        mean you have to use it for everything**; there may be reasons
        to create [some components in BEM style](https://css-tricks.com/bem-101/)
        because they are just too complex to handle with Eezo;

        BEM is a good way to augment Eezo, because if done correctly,
        it will maintain the flat specificity that Eezo uses
        to compose classes.

    :prismjs( language = "html" )
        <!-- html -->
        <div class="my-component / white bg-dark f1 pad-4">
            <h3 class="my-component__header / f3"></h3>
        </div>

    :prismjs( language = "css" )
        /* css that will nicely override the
            classes from eezo */
        .my-component { /* ... */ }
        .my-component__header { /* ... */ }

    +source-file( "/src/config/_breakpoints.scss" )
