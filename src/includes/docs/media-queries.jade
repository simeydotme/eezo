
extends ./layout/columns

block title
    | docs | media queries








append content



    +main-title( "Media Queries" )

    +intro-text
        :marked
            Having a **composable css class system** would not
            be very useful if it only applied to a single breakpoint.

    :marked
        A lot of layout and **design needs to shift** according to the
        size of the **user's screen**, and so we are able to
        prefix the css classes with `tb-*` and `dt-*` by default
        to allow a [mobile-first](http://zellwk.com/blog/how-to-write-mobile-first-css/)
        approach to design.

        **Not all components** of Eezo **have media-specific class
        prefixes**. This is because some of the css properties are
        considered to be _screen-size-agnostic_; you shouldn't need to
        change the `cursor` style, or `font-weight` across screen sizes.

        _Also see the [mixins section](xxmixinsxx) for info on how you can use
        the Eezo breakpoints system in your own application css._


    +sub-title( "Default Breakpoints" )

    :marked
        The **default breakpoints** are defined in a way **which I find**
        is how most non-developers think about responsive design; in
        the "_mobile, tablet, desktop_" mind-set.

        I am **not saying this is correct**, but due to the popularity of
        certain devices, and the general way css frameworks are built,
        this information has been spread _for better or worse_.

        _But the beauty is that these defaults are configurable, and
        overridable!!_


    +sub-title( "Values" )

    :marked
        Here's a look at the default values for the `$breakpoints` map.
        This map is used throughout the components to define the `min-width`
        breakpoints.

    :prismjs( language = "scss" )
        // the breakpoints defined, and their
        // corresponding min-width values.
        $breakpoints: (
            mb: 0,
            tb: 768px,
            dt: 1024px,
            hg: 1200px,
        ) !default;

    :marked
        This means that anything with the `mb` prefix will be
        applied universally. But anything with
        - `tb` prefix, applies to `768px` and up
        - `dt` prefix, applies to `1024px` and up
        - `hg` prefix, applies to `1200px` and up

        Although, technically no components use `hg`, that
        breakpoint, by default, is just there for custom
        css.

    :prismjs( language = "scss" )
        // the default breakpoints list
        $default-bps: ("mb", "tb", "dt") !default;

    :marked
        The list shown above is a set of references to the `$breakpoints` map.

        The way this works is that in each component which supports media query
        prefixes, we will loop through `$default-bps` and attempt to pluck each
        matching media query definition from the `$breakpoints` map.

        Eezo's css components **will not create a class-prefix for the first item**.
        So the definition for `font-size: 1rem` will be:

    :prismjs( language = "css" )
        .f0 { font-size: 1rem; }
        .tb-f0 { font-size: 1rem; }
        .dt-f0 { font-size: 1rem; }

    +sub-title( "Customising" )

    :marked
        Eezo does not presume to say what breakpoints you should use
        in your application, that's your choice and so it's
        pretty easy to customise them by defining your own
        `$breakpoints` map and `$default-bps` list;

    +small-title( "General Breakpoints" )

    :marked
        There's a global default for breakpoints, which when
        modified will apply to all components and update their
        prefixes accordingly.

    :prismjs( language = "scss" )
        // let's change the breakpoints
        // to something similar to bootstrap;

        $breakpoints: (

            xs: 0,
            sm: 768px,
            md: 992px,
            lg: 1200px

        );

        // and define the list to reference
        // all these breakpoints;

        $default-bps: ( "xs", "sm", "md", "lg" );

    :marked
        With the code block above placed in to your `.scss` file
        (as described in the [customising Eezo section](/dist/docs/customising.html)) an
        example output of code for the `display` component would be:

    :prismjs( language = "css" )
        /* an example of the code now generated by
            the customised breakpoints */

            .disp-n  { display: none; }
            .disp-i  { display: inline; }
            .disp-b  { display: block; }
            /* ... */

        @media screen and ( min-width: 48em ) {
            .sm-disp-n  { display: none; }
            .sm-disp-i  { display: inline; }
            .sm-disp-b  { display: block; }
            /* ... */
        }

        @media screen and ( min-width: 62em ) {
            .md-disp-n  { display: none; }
            .md-disp-i  { display: inline; }
            .md-disp-b  { display: block; }
            /* ... */
        }

        @media screen and ( min-width: 75em ) {
            .lg-disp-n  { display: none; }
            .lg-disp-i  { display: inline; }
            .lg-disp-b  { display: block; }
            /* ... */
        }

    :marked
        As you can see, the generation of this code is
        automatic, and required little effort from the
        developer.

    +small-title( "Targetted Breakpoints" )

    :marked
        Aside from the global breakpoints, it's also
        possible to define breakpoints for each component
        individually. This is useful if you think that
        one component will need more/less breakpoints
        than the rest of the application.

    :prismjs( language = "scss" )
        // we will make floats only apply
        // to the small and large breakpoints we
        // defined above in $breakpoints.
        $float-bps: ( "xs", "lg" );

    :marked
        This would then generate the `float` component with
        less breakpoint-specific prefixes than the rest
        of the application.

    :prismjs( language = "css" )
        /* an example of the code now generated by
            the customised float breakpoints */

        .float-l { float: left; }
        .float-r { float: right; }
        .float-n { float: none; }

        @media screen and ( min-width: 75em ) {
            .lg-float-l { float: left; }
            .lg-float-r { float: right; }
            .lg-float-n { float: none; }
        }

    :marked
        Check each individual component's documentation page to
        find out how to customise the targetted breakpoints.

    +sub-title( "Best Practises" )

    :marked
        _Refer to the [Tips & Tricks section]() for a more
        general overview of best practises._

        These breakpoints apply to a **large number of
        components** with a **lot of css**. Although Eezo is designed
        to take advantage of [GZIP](http://www.infinitepartitions.com/art001.html)
        by having a lot of repetitive code, it is not ideal
        to be supplying a large number of breakpoints
        for a few reasons;

        1. **User Experience** - You do not want a large amount of
        css repeated unnecessarily, it will bloat your css
        file and increase download/render times.
        2. **Developer Usability** - Trying to remember a large
        amount of breakpoints will be troublesome in development.

    +small-title( "Only Neccessary Breakpoints" )

    :marked
        Try to **keep your defined breakpoints to a minimum**.
        If you find a reason to have more breakpoints,
        consider [modifying the `$*-bps` variable](#targetted-breakpoints) for **specific
        components** rather than applying them globally.

        And remember, if a certain part of your website needs to have
        much more fine control over it's layout across media queries,
        it's probably better to use BEM style css to handle that.

    +small-title( "Augment with BEM" )

    :marked
        Eezo is a composable class framework designed to create
        a **reusable system** across your application. But that **doesn't
        mean you have to use it for everything**; there may be reasons
        to create [some components in BEM style](https://css-tricks.com/bem-101/)
        because they are just too complex to handle with Eezo;

        BEM is a good way to augment Eezo, because if done correctly,
        it will maintain the flat specificity that Eezo uses
        to compose classes.

    :prismjs( language = "html" )
        <!-- html -->
        <div class="my-component / white bg-dark f1 pad-4">
            <h3 class="my-component__header / f3"></h3>
        </div>

    :prismjs( language = "css" )
        /* css that will nicely interact with the
            classes from eezo */
        .my-component { /* ... */ }
        .my-component__header { /* ... */ }

    +small-title( "Template your HTML" )

    :marked
        **Not your CSS**.

        One reaction people have to composable/atomic
        css is that _it will be hard to replace things across the
        application if they change_. Well, a simple solution (and one that
        you should really be doing either way) is **templating your HTML**.

        **If you need buttons across your app to have a consistent style, then
        template them!** That way you only need to change the template.

    :prismjs( language = "jade" )
        <!-- a .jade button mixin -->
        <!-- buttons don't have a margin by default. -->

        mixin button( classes )
            button( class = classes ).pad-5.rad-3.white.bg-pitch
                block

        mixin cancelButton( classes )
            button( class = classes ).pad-5.rad-3.pitch.bg-white.bor-1.bor-pitch
                block

    :prismjs( language = "jade" )
        <!-- a .jade template file -->
        <!-- these buttons need BEM classes, plus a margin. -->

        form.form-component
            +cancelButton( "form-component__cancel mar-2" )
                | Cancel

            +button( "form-component__submit mar-2" )
                | Submit This Form

    :prismjs( language = "html" )
        <!-- output html -->
        <form class="form-component">
            <button class="form-component__cancel mar-2 pad-5 rad-3 pitch bg-white bor-1 bor-pitch">
                Cancel
            </button>

            <button class="form-component__submit mar-2 pad-5 rad-3 white bg-pitch">
                Submit This Form
            </button>
        </form>

    :marked
        Above is a great example of how **you can maintain a consistent
        style** of buttons **across your application**, but also have
        **fine control over each** one by supplying custom css classes
        in a BEM style.

        In this case it's demonstrated using `.jade`, but
        you can use `twig` or `jstl` or `razor` or whatever template
        engine you desire.

    +source-file( "/src/config/_breakpoints.scss" )
